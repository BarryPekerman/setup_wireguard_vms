#!/bin/bash

# WireGuard AWS Setup Script
# This script automates the entire setup process

set -euo pipefail

# Optional env file support
set -a
[ -f ./.env ] && . ./.env || true
[ -f ./scripts/setup.env ] && . ./scripts/setup.env || true
set +a

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Detect local public IP
detect_local_ip() {
    print_status "Detecting your public IP address..."
    
    # Try multiple methods to get public IP
    LOCAL_IP=""
    
    # Method 1: curl to ipify.org
    if command -v curl &> /dev/null; then
        LOCAL_IP=$(curl -4 -s --connect-timeout 5 https://api.ipify.org 2>/dev/null || echo "")
    fi
    
    # Method 2: curl to icanhazip.com
    if [ -z "$LOCAL_IP" ] && command -v curl &> /dev/null; then
        LOCAL_IP=$(curl -4 -s --connect-timeout 5 https://ipv4.icanhazip.com 2>/dev/null || echo "")
    fi
    
    # Method 3: dig to OpenDNS
    if [ -z "$LOCAL_IP" ] && command -v dig &> /dev/null; then
        LOCAL_IP=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null || echo "")
    fi
    
    # Method 4: curl to httpbin.org
    if [ -z "$LOCAL_IP" ] && command -v curl &> /dev/null; then
        LOCAL_IP=$(curl -4 -s --connect-timeout 5 https://httpbin.org/ip 2>/dev/null | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1 || echo "")
    fi
    
    if [ -z "$LOCAL_IP" ]; then
        print_error "Could not detect your public IP address. Please set allowed_ssh_cidr manually in terraform/terraform.tfvars"
        exit 1
    fi
    
    print_status "Detected public IP: $LOCAL_IP"
    LOCAL_IP_CIDR="${LOCAL_IP}/32"
    print_status "SSH access will be restricted to: $LOCAL_IP_CIDR"
}

# Update terraform.tfvars with detected IP
update_terraform_config() {
    print_status "Updating Terraform configuration with your IP..."
    
    cd terraform
    
    # Check if terraform.tfvars exists
    if [ ! -f terraform.tfvars ]; then
        print_warning "terraform.tfvars not found. Creating from example..."
        cp terraform.tfvars.example terraform.tfvars
    fi
    
    # Update the allowed_ssh_cidr with detected IP
    if grep -q "allowed_ssh_cidr" terraform.tfvars; then
        # Update existing line
        sed -i "s|allowed_ssh_cidr = .*|allowed_ssh_cidr = \"$LOCAL_IP_CIDR\"|" terraform.tfvars
    else
        # Add new line
        echo "" >> terraform.tfvars
        echo "# Auto-detected IP for SSH access" >> terraform.tfvars
        echo "allowed_ssh_cidr = \"$LOCAL_IP_CIDR\"" >> terraform.tfvars
    fi
    
    print_status "Updated terraform.tfvars with your IP: $LOCAL_IP_CIDR"
    cd ..
}

# Check prerequisites
check_prerequisites() {
    print_status "Checking prerequisites..."
    
    # Check if terraform is installed
    if ! command -v terraform &> /dev/null; then
        print_error "Terraform is not installed. Please install it first."
        exit 1
    fi
    
    # Check if ansible is installed
    if ! command -v ansible &> /dev/null; then
        print_error "Ansible is not installed. Please install it first."
        exit 1
    fi
    
    # Check if AWS CLI is configured
    if ! aws sts get-caller-identity &> /dev/null; then
        print_error "AWS CLI is not configured. Please run 'aws configure' first."
        exit 1
    fi
    
    # Note: SSH key is auto-generated by create_project_ssh_key() - no need to check for existing keys
    
    print_status "All prerequisites met!"
}


# Create project-specific SSH key pair
create_project_ssh_key() {
    print_status "Creating project-specific SSH key pair..."
    
    # Use a stable key name so repeated runs reuse the same key instead of
    # creating a new timestamped key each time (which breaks SSH/Ansible).
    local base_name="${PROJECT_NAME:-wireguard-setup}"
    local key_name="wireguard-${base_name}"
    local key_path="${HOME}/.ssh/${key_name}"
    local timestamp
    timestamp=$(date +%s)
    local comment="wireguard-setup-$(date +%Y%m%d)-${timestamp}"
    
    # Check if key already exists; if so, reuse it
    if [ -f "${key_path}" ]; then
        print_warning "SSH key already exists: ${key_name}"
        print_status "Using existing key"
        export PROJECT_PRIVATE_KEY_PATH="${key_path}"
        export PROJECT_PUBLIC_KEY_PATH="${key_path}.pub"
        # Ensure Terraform variables point at this stable key path
        if [ -f terraform/terraform.tfvars ]; then
            sed -i "s|^public_key_path .*|public_key_path = \"${key_path}.pub\"|" terraform/terraform.tfvars || true
            sed -i "s|^private_key_path .*|private_key_path = \"${key_path}\"|" terraform/terraform.tfvars || true
        fi
        return 0
    fi
    
    # Create SSH key pair (Ed25519 - modern, secure, fast)
    if ssh-keygen -t ed25519 -f "${key_path}" -N "" -C "${comment}"; then
        print_success "SSH key pair created: ${key_name}"
        print_status "Private key: ${key_path}"
        print_status "Public key: ${key_path}.pub"
        print_status "Comment: ${comment}"
        
        # Set environment variables for Terraform
        export PROJECT_PRIVATE_KEY_PATH="${key_path}"
        export PROJECT_PUBLIC_KEY_PATH="${key_path}.pub"
        
        # Update Terraform variables (replace existing values) so that the
        # aws_key_pair resource and generated Ansible inventory stay in sync
        if [ -f terraform/terraform.tfvars ]; then
            sed -i "s|^public_key_path .*|public_key_path = \"${key_path}.pub\"|" terraform/terraform.tfvars || true
            sed -i "s|^private_key_path .*|private_key_path = \"${key_path}\"|" terraform/terraform.tfvars || true
        fi
        
        return 0
    else
        print_error "Failed to create SSH key pair"
        return 1
    fi
}

# Deploy infrastructure with retry logic
deploy_infrastructure() {
    print_status "Deploying AWS infrastructure..."
    
    cd terraform
    
    # Initialize terraform with retry
    local max_retries=3
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        print_status "Initializing Terraform (attempt $((retry_count + 1))/$max_retries)..."
        if terraform init -upgrade; then
            print_success "Terraform initialized successfully"
            break
        else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
                print_warning "Terraform init failed, retrying in 30 seconds..."
                sleep 30
            else
                print_error "Terraform init failed after $max_retries attempts"
                cd ..
                return 1
            fi
        fi
    done
    
    # Apply with retry (no saved plan file to avoid staleness issues)
    retry_count=0
    while [ $retry_count -lt $max_retries ]; do
        print_status "Applying Terraform deployment (attempt $((retry_count + 1))/$max_retries)..."
        if terraform apply -auto-approve; then
            print_success "Infrastructure deployed successfully"
            break
        else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
                print_warning "Terraform apply failed, retrying in 60 seconds..."
                sleep 60
            else
                print_error "Infrastructure deployment failed after $max_retries attempts"
                print_error "Check AWS console for any resource conflicts or permission issues"
                cd ..
                return 1
            fi
        fi
    done
    
    cd ..
}

# Get infrastructure outputs
get_outputs() {
    print_status "Getting infrastructure outputs..."
    
    cd terraform
    BASTION_IP=$(terraform output -raw bastion_public_ip)
    PRIVATE_IP=$(terraform output -raw private_instance_ip)
    print_status "Bastion IP: $BASTION_IP"
    print_status "Private IP: $PRIVATE_IP"
    cd ..
}

# Update Ansible inventory
update_inventory() {
    print_status "Updating Ansible inventory..."

    bash ./ansible/scripts/generate_inventory_from_tf.sh

    print_status "Inventory generated at ansible/inventory/infrastructure.ini"
}

# Run Ansible playbook with retry logic
run_ansible() {
    print_status "Running Ansible playbook..."
    
    cd ansible
    
    # Install requirements with retry
    local max_retries=3
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        print_status "Installing Ansible requirements (attempt $((retry_count + 1))/$max_retries)..."
        if ansible-galaxy collection install -r requirements.yml; then
            print_success "Ansible requirements installed successfully"
            break
        else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
                print_warning "Ansible requirements installation failed, retrying in 30 seconds..."
                sleep 30
            else
                print_error "Failed to install Ansible requirements after $max_retries attempts"
                cd ..
                return 1
            fi
        fi
    done
    
    # Run playbook with retry
    retry_count=0
    while [ $retry_count -lt $max_retries ]; do
        print_status "Running Ansible playbook (attempt $((retry_count + 1))/$max_retries)..."
        if ansible-playbook playbooks/wireguard.yml -i inventory/infrastructure.ini --timeout=300; then
            print_success "Ansible playbook completed successfully"
            break
        else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
                print_warning "Ansible playbook failed, retrying in 60 seconds..."
                sleep 60
            else
                print_error "Ansible playbook failed after $max_retries attempts"
                print_error "Check SSH connectivity and instance status"
                cd ..
                return 1
            fi
        fi
    done
    
    cd ..
}

# Test connection
test_connection() {
    print_status "Testing SSH connection to bastion..."
    
    # Prefer the project-specific SSH key created earlier, with a sane
    # fallback to the stable default path if the env var is missing.
    local ssh_key="${PROJECT_PRIVATE_KEY_PATH:-$HOME/.ssh/wireguard-wireguard-setup}"
    # StrictHostKeyChecking=no is acceptable here because:
    # 1. We JUST created these instances seconds ago (known fresh)
    # 2. This is automated testing, not interactive user connection
    # 3. The instances haven't been added to known_hosts yet
    local ssh_opts="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=15"
    
    # Test bastion connectivity via SSH (not ping - ICMP blocked by security group)
    if ssh -i "$ssh_key" $ssh_opts ubuntu@$BASTION_IP "echo 'ok'" &> /dev/null; then
        print_status "Bastion host is reachable via SSH"
    else
        print_error "Cannot reach bastion host via SSH"
        return 1
    fi
    
    # Test private instance via bastion
    if ssh -i "$ssh_key" $ssh_opts -o ProxyCommand="ssh -i \"$ssh_key\" $ssh_opts -W %h:%p ubuntu@$BASTION_IP" ubuntu@$PRIVATE_IP "echo 'ok'" &> /dev/null; then
        print_status "Private instance is reachable via bastion"
    else
        print_warning "Cannot reach private instance via bastion (may need more time to boot)"
    fi
}

# Cleanup function for failed deployments
cleanup_on_failure() {
    print_error "Setup failed!"
    if [ -d "terraform" ] && [ -f "terraform/terraform.tfstate" ]; then
        print_warning "Infrastructure may be partially created."
        read -r -p "Do you want to destroy the infrastructure now? [y/N]: " reply
        reply=${reply:-N}
        case "$reply" in
            [yY][eE][sS]|[yY])
                print_warning "Destroying infrastructure..."
                cd terraform
                terraform destroy -auto-approve || print_warning "Terraform destroy failed, manual cleanup may be required"
                cd ..
                ;;
            *)
                print_status "Skipping destroy to allow debugging. You can run './scripts/cleanup.sh' later."
                ;;
        esac
    fi
    print_error "Setup failed. Check the logs above for details."
    exit 1
}

# Main execution with enhanced error handling
main() {
    print_status "Starting WireGuard AWS Setup..."
    
    # Set up error handling
    trap cleanup_on_failure ERR
    
    # Execute setup steps with error checking
    if ! check_prerequisites; then
        print_error "Prerequisites check failed"
        exit 1
    fi
    
    if ! detect_local_ip; then
        print_error "IP detection failed"
        exit 1
    fi
    
    if ! create_project_ssh_key; then
        print_error "SSH key creation failed"
        exit 1
    fi
    
    if ! update_terraform_config; then
        print_error "Terraform configuration update failed"
        exit 1
    fi
    
    if ! deploy_infrastructure; then
        print_error "Infrastructure deployment failed"
        cleanup_on_failure
    fi
    
    if ! get_outputs; then
        print_error "Failed to get infrastructure outputs"
        cleanup_on_failure
    fi
    
    if ! update_inventory; then
        print_error "Inventory update failed"
        cleanup_on_failure
    fi
    
    if ! run_ansible; then
        print_error "Ansible configuration failed"
        cleanup_on_failure
    fi
    
    if ! test_connection; then
        print_warning "Connection test failed, but setup may still be functional"
    fi
    
    # Clear error trap on success
    trap - ERR
    
    # Use the same project-specific SSH key that Terraform/Ansible used
    local ssh_key="${PROJECT_PRIVATE_KEY_PATH:-$HOME/.ssh/wireguard-wireguard-setup}"
    
    print_success "Setup completed successfully!"
    print_status "You can now connect to the private instance via bastion:"
    print_status "ssh -i \"$ssh_key\" -o ProxyCommand='ssh -i \"$ssh_key\" -W %h:%p ubuntu@$BASTION_IP' ubuntu@$PRIVATE_IP"
    print_status ""
    print_status "To set up WireGuard VPN for direct access (recommended):"
    print_status "./scripts/wireguard_client.sh           # Quick config generation"
    print_status "./scripts/wireguard_client.sh --auto    # Full auto-setup"
    print_status "./scripts/wireguard_client.sh --help    # Show all options"
    print_status ""
    print_status "To clean up everything when done:"
    print_status "./scripts/cleanup.sh                   # Cleanup (infrastructure + WireGuard)"
    print_status "./scripts/cleanup.sh --help            # Show all cleanup options"
}

# Run main function
main "$@"

